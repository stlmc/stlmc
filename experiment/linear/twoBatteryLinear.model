# model description:
#
# There are two fully charged batteries, and a control
# system that switches load between these batteries.
# The goal of the control system is to achieve longer
# battery lifetime.

int b1;
int b2;

[-10, 10] g1;
[-10, 10] g2;
[-10, 10] d2;
[-10, 10] d1;

# state
# 1 : ON
# 2 : OFF
# 3 : DEAD 
{
    mode:
        b1 = 1;
        b2 = 1;
    inv:
 	g1 > 0.5;
	g2 > 0.5;
    flow:
        d/dt[d1] = 0.5 / 0.166 ;
        d/dt[d2] = 0.5 / 0.166 ;
        d/dt[g1] = -0.5 ;
        d/dt[g2] = -0.5 ;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 1) (b2' = 2) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 2) (b2' = 1) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 3) (b2' = 1) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (b1' = 1) (b2' = 3) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (b1' = 3) (b2' = 3) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
}
{
    mode:
        b1 = 1 ;
        b2 = 2 ;
    inv:
	g1 > 0.5;
	d2 > 1;
    flow:
        d/dt[d1] = 0.7 / 0.166 ;
        d/dt[d2] = -0.166 ;
        d/dt[g1] = -1 ;
        d/dt[g2] = 0 ;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 2) (b2' = 1) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 1) (b2' = 1) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 3) (b2' = 1) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (b1' = 1) (b2' = 3) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (b1' = 3) (b2' = 3) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
}
{
    mode:
        b1 = 2;
        b2 = 1;
    inv:
	d1 > 1;
	g2 > 0.5;
    flow:
        d/dt[d1] = -0.166 ;
        d/dt[d2] = 0.7 / 0.166 ;
        d/dt[g1] = 0 ;
        d/dt[g2] = -1 ;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 1) (b2' = 2) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 1) (b2' = 1) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 3) (b2' = 1) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (b1' = 1) (b2' = 3) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (b1' = 3) (b2' = 3) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));

}
{
    mode:
        b1 = 3;
        b2 = 1;
    inv:
	g1 < 1;
	g2 > 0.5;
    flow:
        d/dt[d1] = 0 ;
        d/dt[d2] = 0.7 / 0.166 ;
        d/dt[g1] = 0 ;
        d/dt[g2] = -1 ;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 1) (b2' = 2) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 2) (b2' = 1) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 1) (b2' = 1) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (b1' = 1) (b2' = 3) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (b1' = 3) (b2' = 3) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
}
{
    mode:
        b1 = 1;
        b2 = 3;
    inv:
	g1 > 0.5;
	g2 < 1;
    flow:
        d/dt[d1] = 0.7 / 0.166 ;
        d/dt[d2] = 0; 
        d/dt[g1] = -1 ;
        d/dt[g2] = 0 ;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 1) (b2' = 2) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 2) (b2' = 1) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 1) (b2' = 1) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1- 0.3)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 3) (b2' = 1) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (b1' = 3) (b2' = 3) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
}
{
    mode:
        b1 = 3;
        b2 = 3;
    inv:
	g1 < 0.5;
	g2 < 0.5;
    flow:
        d/dt[d1] = 0 ; 
        d/dt[d2] = 0 ;
        d/dt[g1] = 0 ;
        d/dt[g2] = 0 ;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 1) (b2' = 2) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 2) (b2' = 1) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 1) (b2' = 1) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 > ((1 - 0.166) * d2))) =>
          (and (b1' = 3) (b2' = 1) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1 )) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (b1' = 1) (b2' = 3) (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
}
init:
(and (b1 = 1) (b2 = 1) (g1 = 8.5) (d1 = 0) (g2 = 7.5) (d2 = 0)) ;

propositions:
reachability = g2 > 4 ;
modeLL = (d1 > 0.3); 
donegzero = d1 > 0.2 ;
dtwogzero = d2 > 0.2;
modeDD = (d1 < 0.1); 

goal:
([] [0.0, 40.0] (reachability -> <>[0.0, 20.0) (d2 > 0))) ; # true
((g2 > 0.5) R [0, 40] (b2 = 3)); # true
(<> [0.0, 100.0) donegzero); # false
(<> (10.0,50.0] ((g2 >= 0) U(1.0,15.0) modeDD)); # false


