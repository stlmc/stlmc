# timebound 10

const real vlow = 10 ;
const real vhigh = 50;
const real goal = 30;
int m;
[0, 100] x;
[0, 100] y;
[-1, 1] phi;

# Left
{
  mode :
	m = 1;
  inv: 
	(goal - theta) < - 5;
  flow:
        d/dt[x] = vlow * cos(theta); 
        d/dt[y] = vlow * sin(theta);
        d/dt[theta] = vlow * tan(-45);
  jump:
        (and ((goal - theta) > -5) ((goal -theta) < 5)) =>
         (and (m' = 2) (x' = x) (y' = y) (theta' = theta) (v' = v) (phi' = -30));
}
{mode:
      m = 2;

  inv:
        x > 0;
        y > 0;
  flow:
        d/dt[x] = v * cos(theta);
        d/dt[y] = v * sin(theta);
        d/dt[theta] = v * tan(phi);
        d/dt[phi] = -0.01 * phi;
        d/dt[v] = -5;
  jump:
        (and (x > 0) (y > 0)) =>
         (and (m' = 1) (x' = x) (y' = y) (theta' = theta) (v' = v) (phi' = 30));
        (and (x > 0) (y > 0)) =>
         (and (m' = 2) (x' = x) (y' = y) (theta' = theta) (v' = v) (phi' = 0));
        (and (x > 0) (y > 0)) =>
         (and (m' = 3) (x' = x) (y' = y) (theta' = theta) (v' = v) (phi' = -30));

}
{ 
  mode : 
	m = 3;
  inv:
        x > 0;
        y > 0;
  flow:
        d/dt[x] = v * cos(theta);
        d/dt[y] = v * sin(theta);
        d/dt[theta] = v * tan(phi);
        d/dt[phi] = -0.01 * phi;
        d/dt[v] = -0.1 * v;
  jump:
        (and (x > 0) (y > 0)) =>
         (and (m' = 1) (x' = x) (y' = y) (theta' = theta) (v' = v) (phi' = 30));
        (and (x > 0) (y > 0)) =>
         (and (m' = 2) (x' = x) (y' = y) (theta' = theta) (v' = v) (phi' = 0));
        (and (x > 0) (y > 0)) =>
         (and (m' = 3) (x' = x) (y' = y) (theta' = theta) (v' = v) (phi' = -30));

}

init:
(and (m = 1) (x >= 40 - 0.1) (x <= 40 + 0.1) (y = 30) (v = 5) (theta = 0) (phi = 0));

propositions:
p1 = x > 60;
p2 = theta > 5;

goal:
#reach (and p1 p2); 
(<> [10, 50) p1); # false
((theta < 30) U [4, 10] (y < 40)); # true
(<> [20, 50] ([] [15, 20] x > 70)); # false
([] [0, 10] (y < 70 U [10, 20] phi > -5)); # true


