# model description:
#
# There are two fully charged batteries, and a control
# system that switches load between these batteries.
# The goal of the control system is to achieve longer
# battery lifetime.
# timebound is 1

bool a;
bool b;
bool c;
[-10, 10] d1;
[-10, 10] d2;
[-10, 10] g1;
[-10, 10] g2;
{
    mode:
	a = false;
	b = false;
	c = false;
    inv:
        g1 > 0;
        g2 > 0;
    flow:
        d/dt[d1] = (0.5 / 0.166) - (0.122 * d1) ;
        d/dt[d2] = (0.5 / 0.166) - (0.122 * d2) ;
        d/dt[g1] = -0.5 ;
        d/dt[g2] = -0.5;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (a' = true) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (a' = true) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
}
{
    mode:
        a = false;
        b = false;
        c = true;
    inv:
        g1 > 0;
        g2 > 0;
    flow:
        d/dt[d1] = (1 / 0.166) - (0.122 * d1) ;
        d/dt[d2] = -(0.122 * d2) ;
        d/dt[g1] = -1 ;
        d/dt[g2] = 0;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (a' = true) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (a' = true) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
}
{
    mode:
        a = false;
        b = true;
        c = false;
    inv:
        g1 > 0;
        g2 > 0;
    flow:
        d/dt[d1] = -(0.122 * d1) ;
        d/dt[d2] = (1 / 0.166) - (0.122 * d2) ;
        d/dt[g1] = 0 ;
        d/dt[g2] = -1;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (a' = true) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (a' = true) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
}
{
    mode:
        a = false;
        b = true;
        c = true;
    inv:
        g2 > 0;
    flow:
        d/dt[d1] = 0 ;
        d/dt[d2] = (1 / 0.166) - (0.122 * d2) ;
        d/dt[g1] = 0 ;
        d/dt[g2] = -1;
    jump:
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (a' = true) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
}
{
    mode:
        a = true;
        b = false;
        c = false;
    inv:
        g1 > 0;
    flow:
        d/dt[d1] = (1 / 0.166) - (0.122 * d1) ;
        d/dt[d2] = 0 ;
        d/dt[g1] = -1 ;
        d/dt[g2] = 0;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (a' = true) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1 - 0.3)) (g2 <= ((1 - 0.166) * d2 - 0.3))) =>
          (and (a' = true) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2));
}
{
    mode:
        a = true;
        b = false;
        c = true;
    inv:
        g1 < 0.1;
        g2 < 0.1;
    flow:
        d/dt[d1] = 0;
        d/dt[d2] = 0;
        d/dt[g1] = 0;
        d/dt[g2] = 0;
    jump:
	
}
init:
(and (a = false) (b = false) (c = false) (g1 = 8.5) (d1 = 0) (g2 = 7.5) (d2 = 0));

propositions:
reachability = d1 > 5 ;
modeLL = (d1 > 0.3); 
donegzero = d1 > 0.5 ;
dtwogzero = d2 > 0.5;
modeDD = (d1 < 0.1); 

goal:
([] (5.0,30.0] (<>[0.5,25) (g1 < 0.1))); # false
([] [0, 30] (g1 > 0)); # true
(<> (0.0,50.0) dtwogzero); # false
([] (10.0,50.0] ((g1 >= 0.5) U(1.0,15.0) (g1 > 0.5))); # true


