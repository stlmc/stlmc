bool r;
bool d;
[0, 100] x1;
[0, 100] y1;
[-40, 40] phi1;
[-1.5 , 1.5] theta1;
[0, 100] x2;
[0, 100] y2;

#  car1 : straight
{
    mode:
        r = false;
        d = false;
    inv:
    flow:
        d/dt[x1] = 3 * cos(theta1);
        d/dt[y1] = 3 * sin(theta1);
	d/dt[x2] = 2;
	d/dt[y2] = 2;
	d/dt[theta1] = 0;
	d/dt[phi1] = 0;
    jump:
	(y2 - y1) >= 1 =>
		(and (r' = true) (d' = false) (x1' = x1) (y1' = y1) (x2' = x2) (y2' = y2)
			(theta1' = 0) (phi1' = 30));
        (y2 - y1) <= -1 =>
                (and (r' = true) (d' = true) (x1' = x1) (y1' = y1) (x2' = x2) (y2' = y2)
                        (theta1' = 0) (phi1' = -30));
}
# car1 : left
{
    mode:
        r = true;
        d = false;
    inv:
    flow:
        d/dt[x1] = 2 * cos(theta1);
        d/dt[y1] = -6 * sin(theta1);
        d/dt[x2] = 2;
        d/dt[y2] = 2;
        d/dt[theta1] = -3 * tan(phi1);
        d/dt[phi1] = 0;
    jump:
        (and ((y2 - y1) < 1) ((y2 - y1) > -1)) =>
                (and (r' = false) (d' = false) (x1' = x1) (y1' = y1) (x2' = x2) (y2' = y2)
                        (theta1' = 0) (phi1' = 0));
        (y2 - y1) <= -1 =>
                (and (r' = true) (d' = true) (x1' = x1) (y1' = y1) (x2' = x2) (y2' = y2)
                        (theta1' = 0) (phi1' = -30));

}
# car1 : right
{
    mode:
        r = true;
        d = true;
    inv:
    flow:
        d/dt[x1] = 2 * cos(theta1);
        d/dt[y1] = -6 * sin(theta1);
        d/dt[x2] = 2;
        d/dt[y2] = 2;
        d/dt[theta1] = 3 * tan(phi1);
        d/dt[phi1] = 0;
    jump:
        (y2 - y1) >= 1 =>
                (and (r' = true) (d' = false) (x1' = x1) (y1' = y1) (x2' = x2) (y2' = y2)
                        (theta1' = 0) (phi1' = 30));
        (and ((y2 - y1) < 1) ((y2 - y1) > -1)) =>
                (and (r' = false) (d' = false) (x1' = x1) (y1' = y1) (x2' = x2) (y2' = y2)
                        (theta1' = 0) (phi1' = 0));
}


init:
(and not(r) not(d) (x1 = 0) (y1 = 0) (x2 = 1) (y2 = 1) (theta1 = 0) (phi1 = 0));

propositions:
xg80 = x > 50;
yl50 = y < 50;
xg60 = x > 60;
xg70 = x > 70;

# timebound 20
goal:
~r U [0, 14] (y2 - y1 < 2); # true
<> [0, 20] (d -> (y2 - y1) < 3); # true
[] [0, 20] (y2 > y1); # false at 2
(<> [1, 4] ~d) U [0, 10] (x2 - x1) < 3; # false at 3

