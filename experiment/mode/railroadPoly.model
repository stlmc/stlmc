# model description:
#
# There exist a train and a crossing barrier on a
# circular track. The train is moving around the track.
# The barrier closes or opens depending on the distance
# to the train. The goal of the barrier is to prevent others
# from entering the track when the train passes by.

real m;
[-10, 10] vacc;
[-20, 100] tx;
[0, 90] bx;
[-50, 50] vx;
{
    mode:
        m = 0;
    inv:
	tx > 45;
    flow:
        d/dt[tx] = -5 ;
        d/dt[bx] = vx ;
        d/dt[vx] = vacc ;
        d/dt[vacc] = 0;
    jump:
        (and (40 <= tx) (tx < 50)) =>
          (and (m' = 5) (vacc' = 5) (bx' = bx) (tx' = tx) (vx' = vx));
        (and (10 <= tx) (tx < 30)) =>
          (and (m' = 10) (vacc' = 10) (bx' = bx) (tx' = tx) (vx' = vx)) ;
        (and (-5 <= tx) (tx < 0)) =>
          (and (m' = -5) (vacc' = -5) (bx' = bx) (tx' = tx) (vx' = vx));
}
{
    mode:
        m = 5;
    inv:
	tx > 20;
    flow:
        d/dt[tx] = -5 ;
        d/dt[bx] = vx ;
        d/dt[vx] = vacc ;
        d/dt[vacc] = 0;
    jump:
        (and (10 <= tx) (tx < 30)) =>
          (and (m' = 10) (vacc' = 10) (bx' = bx) (tx' = tx) (vx' = vx)) ;
        (and (-5 <= tx) (tx < 0)) =>
          (and (m' = -5) (vacc' = -5) (bx' = bx) (tx' = tx) (vx' = vx));
        (and (85 <= bx) (tx < -8)) =>
          (and (m' = 0) (vacc' = 0) (bx' = bx) (tx' = (100 + tx)) (vx' = vx));
}
{
    mode:
        m = 10;
    inv:
	bx < 90;
    flow:
        d/dt[tx] = -5 ;
        d/dt[bx] = vx ;
        d/dt[vx] = vacc ;
        d/dt[vacc] = 0;
    jump:
        (and (40 <= tx) (tx < 50)) =>
          (and (m' = 5) (vacc' = 5) (bx' = bx) (tx' = tx) (vx' = vx));
        (and (-5 <= tx) (tx < 0)) =>
          (and (m' = -5) (vacc' = -5) (bx' = bx) (tx' = tx) (vx' = vx));
        (and (85 <= bx) (tx < -8)) =>
          (and (m' = 0) (vacc' = 0) (bx' = bx) (tx' = (100 + tx)) (vx' = vx));
}
{
    mode:
        m = -5;
    inv:
	tx > -10;
    flow:
        d/dt[tx] = -5 ;
        d/dt[bx] = vx ;
        d/dt[vx] = vacc ;
        d/dt[vacc] = 0;
    jump:
        (and (40 <= tx) (tx < 50)) =>
          (and (m' = 5) (vacc' = 5) (bx' = bx) (tx' = tx) (vx' = vx));
        (and (10 <= tx) (tx < 30)) =>
          (and (m' = 10) (vacc' = 10) (bx' = bx) (tx' = tx) (vx' = vx)) ;
        (and (85 <= bx) (tx < -8)) =>
          (and (m' = 0) (vacc' = 0) (bx' = bx) (tx' = (100 + tx)) (vx' = vx));
}
init:
(and (m = 0) (vacc = 2) (bx >= 0) (bx < 1) (tx >= 60) (tx <= 70) (vx <= 0.1) (vx >= 0)) ;

propositions:
# new reachability
# hylaa : 261.44 sec, stlmc : 301.56 sec
reachability = tx < 30;
barg80 = bx >= 80;
barg40 = bx > 40;

goal:
#reach reachability;
# (<> (0.0,50.0) (reachability -> ~barg40));  # True
#([] [20.0,40.0] (<>[1.0,6.0] reachability));
#([] [3.0,50.0] (<>[5.0, 20.0] barg80));
([] [0.0, 50.0] (<>[0.0, 20.0) (tx < 30 -> vx > 2))); # True

