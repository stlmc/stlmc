# model description:
#
# There exist a train and a crossing barrier on a
# circular track. The train is moving around the track.
# The barrier closes or opens depending on the distance
# to the train. The goal of the barrier is to prevent others
# from entering the track when the train passes by.


bool a;
bool b;

[-10, 10] vacc;
[-20, 100] tx;
[0, 90] bx;
[-50, 50] vx;
{
    mode:
        a = false;
        b = false;
    inv:
	tx > 45;
    flow:
        tx(t) = -5 * t  + tx(0);
        bx(t) = -0.01 * t * t + 0.03 *t + bx(0) ;
        vx(t) = 0.01 * t + vx(0) ;
        vacc(t) = vacc(0);
    jump:
        (and (40 <= tx) (tx < 50)) =>
          (and (not a') b' (vacc' = 5) (bx' = bx) (tx' = tx) (vx' = vx));
        (and (10 <= tx) (tx < 30)) =>
          (and (a') (not b') (vacc' = 10) (bx' = bx) (tx' = tx) (vx' = vx)) ;
        (and (-5 <= tx) (tx < 0)) =>
          (and (a') (b') (vacc' = -5) (bx' = bx) (tx' = tx) (vx' = vx));
}
{
    mode:
        a = false;
        b = true;
    inv:
	tx > 20;
    flow:
        tx(t) = -5 * t  + tx(0);
        bx(t) = -0.01 * t * t + 0.03 *t + bx(0) ;
        vx(t) = 0.02 * t + vx(0) ;
        vacc(t) = vacc(0);
    jump:
        (and (10 <= tx) (tx < 30)) =>
          (and (a') (not b') (vacc' = 10) (bx' = bx) (tx' = tx) (vx' = vx)) ;
        (and (-5 <= tx) (tx < 0)) =>
          (and a' b' (vacc' = -5) (bx' = bx) (tx' = tx) (vx' = vx));
        (and (85 <= bx) (tx < -8)) =>
          (and (not a') (not b') (vacc' = 0) (bx' = bx) (tx' = (100 + tx)) (vx' = vx));
}
{
    mode:
        a = true;
        b = false;
    inv:
	bx < 90;
    flow:
        tx(t) = -5 * t  + tx(0);
        bx(t) = 0.01 * t * t + 0.01  * t + bx(0) ;
        vx(t) = 0.01 * t + vx(0) ;
        vacc(t) = vacc(0);
    jump:
        (and (40 <= tx) (tx < 50)) =>
          (and (not a') b' (vacc' = 5) (bx' = bx) (tx' = tx) (vx' = vx));
        (and (-5 <= tx) (tx < 0)) =>
          (and a' b' (vacc' = -5) (bx' = bx) (tx' = tx) (vx' = vx));
        (and (85 <= bx) (tx < -8)) =>
          (and (not a') (not b') (vacc' = 0) (bx' = bx) (tx' = (100 + tx)) (vx' = vx));
}
{
    mode:
        a = true;
        b = true;
    inv:
	tx > -10;
    flow:
        tx(t) = -5 * t  + tx(0);
        bx(t) = -0.02 * t * t + bx(0) ;
        vx(t) = -0.01 * t + vx(0) ;
        vacc(t) = vacc(0);
    jump:
        (and (40 <= tx) (tx < 50)) =>
          (and (not a') b' (vacc' = 5) (bx' = bx) (tx' = tx) (vx' = vx));
        (and (10 <= tx) (tx < 30)) =>
          (and a' (not b') (vacc' = 10) (bx' = bx) (tx' = tx) (vx' = vx)) ;
        (and (85 <= bx) (tx < -8)) =>
          (and (not a') (not b') (vacc' = 0) (bx' = bx) (tx' = (100 + tx)) (vx' = vx));
}
init:
(and (a = false) (b = false) (vacc > 0) (vacc < 0.1) (bx >= 0) (bx < 1) (tx >= 60) (tx <= 70) (vx <= 0.1) (vx >= 0)) ;

propositions:
txg60 = tx > 60;
txg10 = tx > 10;
bxg80 = bx > 80;

goal:
([] [0.0,50.0) (tx > 0)); # true
(txg10 U [0, 100) (and a b)); # false
([] [0, 40] (bxg80 -> (<> [0, 20) txg10))); # true
([] [0, 50) (<> [10, 40] tx < 10)); # false
