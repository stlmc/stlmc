# model description:
#
# There are two fully charged batteries, and a control
# system that switches load between these batteries.
# The goal of the control system is to achieve longer
# battery lifetime.

real startd1;
real startd2;
bool a;
bool b;
bool c;
[-10, 10] d1;
[-10, 10] d2;
[-10, 10] g1;
[-10, 10] g2;
{
    mode:
	a = false;
	b = false;
	c = false;
    inv:
        #g1 > 0.5;
        #g2 > 0.5;
    flow:
	d1(t) = (1 - 2 * t + 2 * t * t) + 1.5 + d1(0);
	d2(t) = (1 - 2 * t + 2 * t * t) + 1.5 + d2(0);
	g1(t) = -0.5 * t + g1(0);
	g2(t) = -0.5 * t + g2(0);
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a' = true) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a' = true) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
}
{
    mode:
        a = false;
        b = false;
        c = true;
    inv:
        #g1 > 0.5;
        #d2 > 1;
    flow:
	d1(t) = (1 - 2 * t + 2 * t * t) + 3.01 + d1(0);
	d2(t) = (1 - 2 * t + 2 * t * t) + d2(0);
	g1(t) = g1(0) - t;
	g2(t) = g2(0);
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a' = true) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a' = true) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
}
{
    mode:
        a = false;
        b = true;
        c = false;
    inv:
        #d1 > 1;
        #g2 > 0.5;
    flow:
	d1(t) = (1 - 2 * t + 2 * t * t) + d1(0);
	d2(t) = (1 - 2 * t + 2 * t * t) + 3.01 + d2(0);
	g1(t) = g1(0);
	g2(t) = g2(0) - t;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a' = true) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a' = true) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
}
{
    mode:
        a = false;
        b = true;
        c = true;
    inv:
        #g1 < 1;
        #g2 > 0.5;
    flow:
	d1(t) = d1(0);
	d2(t) = (1 - 2 * t + 2 * t * t) + 3.01 + d2(0);
	g1(t) = g1(0);
	g2(t) = g2(0) - t;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a' = true) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a' = true) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
}
{
    mode:
        a = true;
        b = false;
        c = false;
    inv:
        #g1 > 0.5;
        #g2 < 1;
    flow:
	d1(t) = (1 - 2 * t + 2 * t * t) + 3.01 + d1(0);
	d2(t) = d2(0);
	g1(t) = g1(0) - t;
	g2(t) = g2(0);
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a' = true) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a' = true) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
}
{
    mode:
        a = true;
        b = false;
        c = true;
    inv:
        #g1 < 0.5;
        #g2 < 0.5;
    flow:
        d/dt[d1] = 0 ; 
        d/dt[d2] = 0 ;
        d/dt[g1] = 0 ;
        d/dt[g2] = 0 ;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (a' = false) (b' = true) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a' = true) (b' = false) (c' = false) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a' = true) (b' = false) (c' = true) (d1' = d1) (d2' = d2) (g1' = g1) (g2' = g2) (startd1' = d1) (startd2' = d2));
}
init:
(and (a = false) (b = false) (c = false) (g1 > 8) (g1 < 9) (d1 >= 0) (d1 < 0.4) (g2 > 7) (g2 < 8) (d2 >= 0) (d2 < 0.4) (startd1 = d1) (startd2 = d2)) ;


propositions:
reachability = g2 < 6 ;
modeLL = (d1 > 0.3);
donegzero = d1 > 0.2 ;
dtwogzero = d2 > 0.2;
modeDD = (d1 < 0.1);

goal:
([] [0.0, 40.0] (reachability -> <>[0.0, 20.0) (d2 > 0))) ; # true
((g2 > 0.5) R [0, 40] (b2 = 3)); # true
(<> [0.0, 100.0) donegzero); # false
(<> (10.0,50.0] ((g2 >= 0) U(1.0,15.0) modeDD)); # false
