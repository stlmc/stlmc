# state
# 00: stay
# 01: accelerate
# 10: deaccelerate

real startv1;
real startv2;
real startphi1;
real startphi2;
real starttheta1;
real starttheta2;
real arbitraryPhi1;
int state;
[0, 10] v1;
[0, 10] v2;
[0, 100] x1;
[0, 100] x2;
[0, 100] y1;
[0, 100] y2;
[-1, 1] phi1;
[-1, 1] phi2;
[-1.5, 1.5] theta1;
[-1.5, 1.5] theta2;
{
    mode:
        state = 1;
    inv:

    flow:
        d/dt[x1] = startv1 * cos(starttheta1); 
        d/dt[x2] = startv2 * cos(starttheta2);
        d/dt[y1] = startv1 * sin(starttheta1);
        d/dt[y2] = startv2 * sin(starttheta2);
        d/dt[v1] = 3;
        d/dt[v2] = (startv1 - startv2);
        d/dt[theta1] = startv1 * tan(startphi1);
        d/dt[theta2] = startv2 * tan(startphi2);
        d/dt[phi1] = 0;
        d/dt[phi2] = (startphi1 - startphi2);
    jump:
        (((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) >= 36) and (((x2 - x1) * (x2 - x1) - (y2 - y1) * (y2 - y1)) <= 81) =>
                (and (state' = 1) (arbitraryPhi1 >= - 0.75) (arbitraryPhi1 <= 0.75) (x1' = x1) (x2' = x2) (v1' = v1) (v2' = v2) (phi1' = arbitraryPhi1) (phi2' = phi2) (theta1' = theta1) (theta2' = theta2) (y1' = y1) (y2' = y2) (startv1' = v1) (startv2' = v2) (startphi1' = phi1) (startphi2' = phi2) (starttheta1' = theta1) (starttheta2' = theta2));
                (((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) < 36) => 
                (and (state' = 2) (arbitraryPhi1 >= - 0.75) (arbitraryPhi1 <= 0.75) (x1' = x1) (x2' = x2) (v1' = v1) (v2' = v2) (phi1' = arbitraryPhi1) (phi2' = phi2) (theta1' = theta1) (theta2' = theta2) (y1' = y1) (y2' = y2) (startv1' = v1) (startv2' = v2) (startphi1' = phi1) (startphi2' = phi2) (starttheta1' = theta1) (starttheta2' = theta2));  
                (((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) > 81) =>
                (and (state' = 3) (arbitraryPhi1 >= - 0.75) (arbitraryPhi1 <= 0.75) (x1' = x1) (x2' = x2) (v1' = v1) (v2' = v2) (phi1' = arbitraryPhi1) (phi2' = phi2) (theta1' = theta1) (theta2' = theta2) (y1' = y1) (y2' = y2) (startv1' = v1) (startv2' = v2) (startphi1' = phi1) (startphi2' = phi2) (starttheta1' = theta1) (starttheta2' = theta2));
}
{
    mode:
        a = false;
        b = true;
    inv:
    
    flow:
        d/dt[x1] = startv1 * cos(starttheta1); 
        d/dt[x2] = startv2 * cos(starttheta2);
        d/dt[y1] = startv1 * sin(starttheta1);
        d/dt[y2] = startv2 * sin(starttheta2);
        d/dt[v1] = 7;
        d/dt[v2] = 5; 
        d/dt[theta1] = startv1 * tan(startphi1);
        d/dt[theta2] = startv2 * tan(startphi2);
        d/dt[phi1] = 0;
        d/dt[phi2] = (startphi1 - startphi2);

    jump:
        (((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) >= 36) and (((x2 - x1) * (x2 - x1) - (y2 - y1) * (y2 - y1)) <= 81) =>
                (and (state' = 1) (arbitraryPhi1 >= - 0.75) (arbitraryPhi1 <= 0.75) (x1' = x1) (x2' = x2) (v1' = v1) (v2' = v2) (phi1' = arbitraryPhi1) (phi2' = phi2) (theta1' = theta1) (theta2' = theta2) (y1' = y1) (y2' = y2) (startv1' = v1) (startv2' = v2) (startphi1' = phi1) (startphi2' = phi2) (starttheta1' = theta1) (starttheta2' = theta2));
                (((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) < 36) =>
                (and (state' = 2) (arbitraryPhi1 >= - 0.75) (arbitraryPhi1 <= 0.75) (x1' = x1) (x2' = x2) (v1' = v1) (v2' = v2) (phi1' = arbitraryPhi1) (phi2' = phi2) (theta1' = theta1) (theta2' = theta2) (y1' = y1) (y2' = y2) (startv1' = v1) (startv2' = v2) (startphi1' = phi1) (startphi2' = phi2) (starttheta1' = theta1) (starttheta2' = theta2));
                (((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) > 81) =>
                (and (state' = 3) (arbitraryPhi1 >= - 0.75) (arbitraryPhi1 <= 0.75) (x1' = x1) (x2' = x2) (v1' = v1) (v2' = v2) (phi1' = arbitraryPhi1) (phi2' = phi2) (theta1' = theta1) (theta2' = theta2) (y1' = y1) (y2' = y2) (startv1' = v1) (startv2' = v2) (startphi1' = phi1) (startphi2' = phi2) (starttheta1' = theta1) (starttheta2' = theta2));
}
{
    mode:
        a = true;
        b = false;
    inv:
        
    flow:
        d/dt[x1] = startv1 * cos(starttheta1);  
        d/dt[x2] = startv2 * cos(starttheta2); 
        d/dt[y1] = startv1 * sin(starttheta1);
        d/dt[y2] = startv2 * sin(starttheta2);
        d/dt[v1] = 2;
        d/dt[v2] = -5;
        d/dt[theta1] = startv1 * tan(startphi1);
        d/dt[theta2] = startv2 * tan(startphi2);
        d/dt[phi1] = 0;
        d/dt[phi2] = (startphi1 - startphi2);
    jump:
        (((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) >= 36) and (((x2 - x1) * (x2 - x1) - (y2 - y1) * (y2 - y1)) <= 81) =>
                (and (state' = 1) (arbitraryPhi1 >= - 0.75) (arbitraryPhi1 <= 0.75) (x1' = x1) (x2' = x2) (v1' = v1) (v2' = v2) (phi1' = arbitraryPhi1) (phi2' = phi2) (theta1' = theta1) (theta2' = theta2) (y1' = y1) (y2' = y2) (startv1' = v1) (startv2' = v2) (startphi1' = phi1) (startphi2' = phi2) (starttheta1' = theta1) (starttheta2' = theta2));
                (((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) < 36) =>
                (and (state' = 2) (arbitraryPhi1 >= - 0.75) (arbitraryPhi1 <= 0.75) (x1' = x1) (x2' = x2) (v1' = v1) (v2' = v2) (phi1' = arbitraryPhi1) (phi2' = phi2) (theta1' = theta1) (theta2' = theta2) (y1' = y1) (y2' = y2) (startv1' = v1) (startv2' = v2) (startphi1' = phi1) (startphi2' = phi2) (starttheta1' = theta1) (starttheta2' = theta2));
                (((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) > 81) =>
                (and (state' = 3) (arbitraryPhi1 >= - 0.75) (arbitraryPhi1 <= 0.75) (x1' = x1) (x2' = x2) (v1' = v1) (v2' = v2) (phi1' = arbitraryPhi1) (phi2' = phi2) (theta1' = theta1) (theta2' = theta2) (y1' = y1) (y2' = y2) (startv1' = v1) (startv2' = v2) (startphi1' = phi1) (startphi2' = phi2) (starttheta1' = theta1) (starttheta2' = theta2));
}

init:
(and (state = 1) (arbitraryPhi1 >= - 0.75) (arbitraryPhi1 <= 0.75) (x1 > 0) (x1 < 3) (x2 > 5) (x2 < 10) (y1 < 10) (y1 > 3) (y2 > 3) (y2 < 10) (v1 >= 1) (v1 <= 3) (v2 >= 3) (v2 <= 4) (theta1 > 0) (theta1 < 1) (theta2 < 0) (theta2 > -1) (phi1 <= 1) (phi1 >= 0) (phi2 <= 0) (phi2 >= -1) (startv1 = v1) (startv2 = v2) (startphi1 = phi1) (startphi2 = phi2) (starttheta1 = theta1) (starttheta2 = theta2));

propositions:
disgzero = ((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) > 0.01 ;
disl6 = ((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) <= 36 ;
modeACC = (state = 2) ;
modeDEC = (state = 3);


reachability = x1 < 27 ;
x2l20 = x2 <= 20 ;
x2g10 = x1 > 10;
x1T = a ;
x2T = b ;

goal:
([] [0.0,100.0] disgzero);
([] [0.0,20.0] (disl6 -> (<> [0.0,15.0] modeACC)));
(<> [12.0,20.0] (modeDEC -> <>[3.0, 18.0] modeACC));
(<> [4.0,40.0] (modeDEC U[10.0, 20.0] (and ((x2 - x1) >= -0.5) ((x2 - x1) <= 0.5) ((y2 - y1) >= -0.5) ((y2 - y1) <= 0.5))));



