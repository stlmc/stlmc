bool a;
bool b;
bool c;
[-10, 10] g1;
[-10, 10] g2;
[-10, 10] d2;
[-10, 10] d1;

# state
# 000: on_1 and on_2
# 001: on_1 and off_2
# 010: off_1 and on_2
# 011: dead_1 and on_2
# 100: on_1 and dead_1
# 101: on_1 and on_2
{
    mode:
        a = false ;
        b = false ;
        c = false ;
    inv:
    flow:
        d/dt[d1] = 0.5 / 0.166 ;
        d/dt[d2] = 0.5 / 0.166 ;
        d/dt[g1] = -0.5 ;
        d/dt[g2] = -0.5 ;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (not b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (not c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a') (not b') (not c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a') (not b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
}
{
    mode:
        a = false ;
        b = false ;
        c = true ;
    inv:
    flow:
        d/dt[d1] = 0.7 / 0.166 ;
        d/dt[d2] = -0.166 ;
        d/dt[g1] = -1 ;
        d/dt[g2] = 0 ;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (not b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (not c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a') (not b') (not c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a') (not b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));

}
{
    mode:
        a = false ;
        b = true ;
        c = false ;
    inv:
    flow:
        d/dt[d1] = -0.166 ;
        d/dt[d2] = 0.7 / 0.166 ;
        d/dt[g1] = 0 ;
        d/dt[g2] = -1 ;
    jump:

        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (not b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (not c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a') (not b') (not c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a') (not b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));

}
{
    mode:
        a = false ;
        b = true ;
        c = true ;
    inv:
    flow:
        d/dt[d1] = 0 ;
        d/dt[d2] = 0.7 / 0.166 ;
        d/dt[g1] = 0 ;
        d/dt[g2] = -1 ;
    jump:

        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (not b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (not c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a') (not b') (not c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a') (not b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));

}
{
    mode:
        a = true ;
        b = false ;
        c = false ;
    inv:
    flow:
        d/dt[d1] = 0.7 / 0.166 ;
        d/dt[d2] = 0; 
        d/dt[g1] = -1 ;
        d/dt[g2] = 0 ;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (not b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (not c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a') (not b') (not c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a') (not b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));



}
{
    mode:
        a = true ;
        b = false ;
        c = true ;
    inv:
    flow:
        d/dt[d1] = 0 ; 
        d/dt[d2] = 0 ;
        d/dt[g1] = 0 ;
        d/dt[g2] = 0 ;
    jump:
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (not b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (not c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 > ((1 - 0.166) * d2))) =>
          (and (not a') (b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 > ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a') (not b') (not c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));
        (and (g1 <= ((1 - 0.166) * d1)) (g2 <= ((1 - 0.166) * d2))) =>
          (and (a') (not b') (c') (d1' = (d1 - 0.122 * g1)) (d2' = (d2 - 0.122 * g2)) (g1' = g1) (g2' = g2));



}
init:
(and not(a) not(b) not(c) (g1 = 8.5) (d1 = 0) (g2 = 7.5) (d2 = 0)) ;

propositions:
reachability = d1 > 1.4 ;
modeFFF = (and (not a) (not b) (not c));
donegzero = d1 > 0.5 ;
dtwogzero = d2 > 0.5;
modeTFT = (and a (not b) c);

goal:
#([] (0.0, 20.5) (<> [3.0, 14.0] reachability)) ;
(<> (5.0,30.0] (modeFFF -> [][7.5,25) modeFFF));
#([] (0.0,50.0) (donegzero and dtwogzero));
#([] (10.0,50.0] (((g1 >= 0) or (g2 >= 0)) U(1.0,15.0) modeTFT));


